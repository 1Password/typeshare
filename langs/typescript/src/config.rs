use serde::{Deserialize, Serialize};
use std::mem;
use std::ops::Add;
#[cfg(feature = "cli")]
use typeshare_core::cli::clap;
use typeshare_core::language::{LanguageConfig, TypeMapping};
use typeshare_module::argument::{ArgumentRef, LanguageArguments};

const DEFAULT_HEADER: &str = r#"
Generated by Typeshare
"#;
/// Enum Write Method for Anonymous Struct Enum Variants
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, Serialize, Deserialize)]
#[cfg_attr(feature = "cli", derive(clap::ValueEnum))]
pub enum EnumWriteMethod {
    ///
    /// ```rust
    /// use serde::{Deserialize, Serialize};
    /// #[derive(Serialize, Deserialize)]
    /// #[serde(tag = "type", content = "value")]
    /// pub enum MyEnum {
    ///     ValueOne { field: String },
    ///     ValueTwo { field: String },
    /// }
    /// ```
    /// ```typescript
    /// // TODO: Add TypeScript Example
    /// ```
    #[default]
    OneType,
    ///
    /// ```rust
    /// use serde::{Deserialize, Serialize};
    /// #[derive(Serialize, Deserialize)]
    /// #[serde(tag = "type", content = "value")]
    /// pub enum MyEnum {
    ///     ValueOne { field: String },
    ///     ValueTwo { field: String },
    /// }
    /// ```
    /// ```typescript
    /// // TODO: Add TypeScript Example
    /// ```
    ManyTypes,
}
pub static DEFAULT_CONFIG: &str = include_str!("default_config.toml");
#[cfg(test)]
mod test {
    use crate::config::TypeScriptConfig;
    use std::ops::DerefMut;
    use std::str::FromStr;
    use toml;
    use typeshare_core::language::type_mapping::ToType;
    use typeshare_core::language::TypeMappingValue;
    use typeshare_core::parsed_types::{Comment, CommentLocation};

    #[test]
    pub fn to_string_test() {
        let mut config = TypeScriptConfig::default();
        config.type_mappings.deref_mut().insert(
            "usize".to_string(),
            TypeMappingValue::from_str("number").unwrap(),
        );
        config.type_mappings.deref_mut().insert(
            "u64".to_string(),
            TypeMappingValue::from_str("number").unwrap(),
        );
        config.type_mappings.deref_mut().insert(
            "duration".to_string(),
            TypeMappingValue {
                to_type: ToType::LangType("number".to_string()),
                doc: Comment::new_single("Duration in seconds".to_string(), CommentLocation::Field),
            },
        );
        let result = toml::to_string_pretty(&config).unwrap();
        println!("{}", result);
        let from_str = toml::from_str::<TypeScriptConfig>(&result);
        println!("{:#?}", from_str);
        assert!(from_str.is_ok());
    }
    #[test]
    pub fn test_default_config() {
        let toml = toml::from_str::<TypeScriptConfig>(super::DEFAULT_CONFIG);
        if let Err(err) = toml {
            panic!("Could not parse default config: {}", err);
        }
        let toml = toml.unwrap();
        println!("{:#?}", toml)
    }
}
#[derive(Serialize, Deserialize, PartialEq, Eq, Debug)]
#[serde(default)]
#[cfg_attr(feature = "cli", derive(clap::Parser))]
pub struct TypeScriptConfig {
    /// Rather or not to use BigInt instead of Number for 64-bit integers.
    #[cfg_attr(feature = "cli", clap(long))]
    pub use_bigint: bool,
    /// Enum Write Method
    #[cfg_attr(feature = "cli", clap(long, default_value = "one-type"))]
    pub enum_write_method: EnumWriteMethod,
    #[cfg_attr(feature = "cli", clap(skip))]
    pub type_mappings: TypeMapping,
    #[cfg_attr(feature = "cli", clap(skip))]
    pub file_header: Option<String>,
    #[cfg_attr(feature = "cli", clap(skip))]
    pub default_file_name: String,
}
impl LanguageArguments for TypeScriptConfig {
    fn get_arguments() -> Vec<ArgumentRef>
    where
        Self: Sized,
    {
        vec![]
    }
}
impl Default for TypeScriptConfig {
    fn default() -> Self {
        TypeScriptConfig {
            use_bigint: true,
            enum_write_method: EnumWriteMethod::default(),
            type_mappings: TypeMapping::default(),
            file_header: Some(DEFAULT_HEADER.to_string()),
            default_file_name: "types.ts".to_string(),
        }
    }
}
impl Add for TypeScriptConfig {
    type Output = Self;

    fn add(mut self, command: Self) -> Self::Output {
        self.use_bigint = command.use_bigint || self.use_bigint;
        self.enum_write_method = command.enum_write_method;
        self
    }
}
impl LanguageConfig for TypeScriptConfig {
    fn default_file_name(&self) -> &str {
        &self.default_file_name
    }

    fn type_mappings(&self) -> &TypeMapping {
        &self.type_mappings
    }

    fn add_common_mappings(&mut self, common_mappings: TypeMapping) {
        self.type_mappings = common_mappings + mem::take(&mut self.type_mappings);
    }

    fn file_header(&self) -> Option<&str> {
        self.file_header.as_deref()
    }
}
