"""
 Generated by typeshare 1.12.0
"""
from __future__ import annotations

from enum import Enum
from pydantic import BaseModel, ConfigDict
from typing import Union


class AutofilledByUs(BaseModel):
    """
    Generated type representing the anonymous struct variant `Us` of the `AutofilledBy` Rust enum
    """
    uuid: str
    """
    The UUID for the fill
    """


class AutofilledBySomethingElse(BaseModel):
    """
    Generated type representing the anonymous struct variant `SomethingElse` of the `AutofilledBy` Rust enum
    """
    uuid: str
    """
    The UUID for the fill
    """
    thing: int
    """
    Some other thing
    """


class AutofilledByTypes(str, Enum):
    US = "Us"
    SOMETHING_ELSE = "SomethingElse"

class AutofilledBy(BaseModel):
    model_config = ConfigDict(use_enum_values=True)
    type: AutofilledByTypes
    content: Union[AutofilledBySomethingElse, AutofilledByUs]


    @classmethod
    def new_autofilled_by_us(cls, uuid: str):
        return cls(
            type=AutofilledByTypes.US,
            content=AutofilledByUs(uuid = uuid)
	    )


    @classmethod
    def new_autofilled_by_something_else(cls, uuid: str, thing: int):
        return cls(
            type=AutofilledByTypes.SOMETHING_ELSE,
            content=AutofilledBySomethingElse(uuid = uuid, thing = thing)
	    )
class EnumWithManyVariantsAnonVariant(BaseModel):
    """
    Generated type representing the anonymous struct variant `AnonVariant` of the `EnumWithManyVariants` Rust enum
    """
    uuid: str


class EnumWithManyVariantsAnotherAnonVariant(BaseModel):
    """
    Generated type representing the anonymous struct variant `AnotherAnonVariant` of the `EnumWithManyVariants` Rust enum
    """
    uuid: str
    thing: int


class EnumWithManyVariantsTypes(str, Enum):
    UNIT_VARIANT = "UnitVariant"
    TUPLE_VARIANT_STRING = "TupleVariantString"
    ANON_VARIANT = "AnonVariant"
    TUPLE_VARIANT_INT = "TupleVariantInt"
    ANOTHER_UNIT_VARIANT = "AnotherUnitVariant"
    ANOTHER_ANON_VARIANT = "AnotherAnonVariant"



class EnumWithManyVariants(BaseModel):
    model_config = ConfigDict(use_enum_values=True)
    type: EnumWithManyVariantsTypes
    content: Union[EnumWithManyVariantsAnonVariant, EnumWithManyVariantsAnotherAnonVariant, None, int, str]


    @classmethod
    def new_enum_with_many_variants_unit_variant(cls) -> EnumWithManyVariants:
        return cls(
            type=EnumWithManyVariantsTypes.UNIT_VARIANT,
            content=None
	    )


    @classmethod
    def new_enum_with_many_variants_tuple_variant_string(cls, content : str):
        return cls(
            type=EnumWithManyVariantsTypes.TUPLE_VARIANT_STRING,
            content=content
        )


    @classmethod
    def new_enum_with_many_variants_anon_variant(cls, uuid: str):
        return cls(
            type=EnumWithManyVariantsTypes.ANON_VARIANT,
            content=EnumWithManyVariantsAnonVariant(uuid = uuid)
	    )


    @classmethod
    def new_enum_with_many_variants_tuple_variant_int(cls, content : int):
        return cls(
            type=EnumWithManyVariantsTypes.TUPLE_VARIANT_INT,
            content=content
        )


    @classmethod
    def new_enum_with_many_variants_another_unit_variant(cls) -> EnumWithManyVariants:
        return cls(
            type=EnumWithManyVariantsTypes.ANOTHER_UNIT_VARIANT,
            content=None
	    )


    @classmethod
    def new_enum_with_many_variants_another_anon_variant(cls, uuid: str, thing: int):
        return cls(
            type=EnumWithManyVariantsTypes.ANOTHER_ANON_VARIANT,
            content=EnumWithManyVariantsAnotherAnonVariant(uuid = uuid, thing = thing)
	    )
