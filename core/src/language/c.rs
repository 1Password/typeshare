use std::io::Write;
use crate::language::Language;
use crate::parser::ParsedData;
use std::collections::HashMap;
use crate::rust_types::RustTypeFormatError;
use crate::rust_types::SpecialRustType;

#[derive(Default)]
pub struct C {
    pub type_mappings: HashMap<String, String>,
}

impl Language for C {
    fn generate_types(
        &mut self,
        w: &mut dyn Write,
        _imports: &super::CrateTypes,
        data: ParsedData,
    ) -> std::io::Result<()> {
        self.begin_file(w, &data)?;

        let ParsedData {
            structs,
            enums,
            aliases,
            consts,
            ..
        } = data;

        for s in structs {
            self.write_struct(w, &s)?;
        }

        for e in enums {
            self.write_enum(w, &e)?;
        }

        for a in aliases {
            self.write_type_alias(w, &a)?;
        }

        for c in consts {
            self.write_const(w, &c)?;
        }

        self.end_file(w)
    }

    fn type_map(&mut self) -> &HashMap<String, String> {
        &self.type_mappings
    }

    fn format_special_type(
        &mut self,
        special_ty: &SpecialRustType,
        generic_types: &[String],
    ) -> Result<String, RustTypeFormatError> {
        Ok(match special_ty {
            SpecialRustType::Vec(rtype) => format!("{}*", self.format_type(rtype, generic_types)?),
            SpecialRustType::Array(rtype, len) => {
                format!("{}[{}]", self.format_type(rtype, generic_types)?, len)
            }
        })
    }

    fn begin_file(&mut self, w: &mut dyn Write, _parsed_data: &ParsedData) -> std::io::Result<()> {
        writeln!(w, "// This code is generated by typeshare")?;
        Ok(())
    }

    fn write_imports(
        &mut self,
        _writer: &mut dyn Write,
        _imports: super::ScopedCrateTypes<'_>,
    ) -> std::io::Result<()> {
        Ok(())
    }
}
            SpecialRustType::Slice(rtype) => format!("{}*", self.format_type(rtype, generic_types)?),
            SpecialRustType::Option(rtype) => format!("{}*", self.format_type(rtype, generic_types)?),
            SpecialRustType::HashMap(rtype1, rtype2) => format!(
                "std::map<{}, {}>",
                self.format_type(rtype1, generic_types)?,
                self.format_type(rtype2, generic_types)?
            ),
            SpecialRustType::Unit => "void".into(),
            SpecialRustType::String => "char*".into(),
            SpecialRustType::Char => "char".into(),
            SpecialRustType::I8 => "int8_t".into(),
            SpecialRustType::U8 => "uint8_t".into(),
            SpecialRustType::I16 => "int16_t".into(),
            SpecialRustType::U16 => "uint16_t".into(),
            SpecialRustType::I32 => "int32_t".into(),
            SpecialRustType::U32 => "uint32_t".into(),
            SpecialRustType::I64 => "int64_t".into(),
            SpecialRustType::U64 => "uint64_t".into(),
            SpecialRustType::ISize => "intptr_t".into(),
            SpecialRustType::USize => "uintptr_t".into(),
            SpecialRustType::Bool => "bool".into(),
            SpecialRustType::F32 => "float".into(),
            SpecialRustType::F64 => "double".into(),
            SpecialRustType::DateTime => "time_t".into(),
        })
    }

    fn write_imports(
        &mut self,
        _writer: &mut dyn Write,
        _imports: super::ScopedCrateTypes<'_>,
    ) -> std::io::Result<()> {
        Ok(())
    }

    fn write_struct(&mut self, w: &mut dyn Write, rs: &crate::rust_types::RustStruct) -> std::io::Result<()> {
        writeln!(w, "typedef struct {} {{", rs.id.original)?;

        for field in &rs.fields {
            let type_name = self.format_type(&field.ty, &[]).unwrap();
            writeln!(w, "    {} {};", type_name, field.id.original)?;
        }

        writeln!(w, "}} {};", rs.id.original)?;
        Ok(())
    }

    fn write_type_alias(&mut self, w: &mut dyn Write, ta: &crate::rust_types::RustTypeAlias) -> std::io::Result<()> {
        let type_name = self.format_type(&ta.r#type, &[]).unwrap();
        writeln!(w, "typedef {} {};", type_name, ta.id.original)?;
        Ok(())
    }

    fn write_const(&mut self, w: &mut dyn Write, c: &crate::rust_types::RustConst) -> std::io::Result<()> {
        let type_name = self.format_type(&c.r#type, &[]).unwrap();
        writeln!(w, "const {} {} = {};", type_name, c.id.original, c.expr)?;
        Ok(())
    }

    fn write_const(&mut self, w: &mut dyn Write, c: &crate::rust_types::RustConst) -> std::io::Result<()> {
        let type_name = self.format_type(&c.r#type, &[]).unwrap();
        writeln!(w, "const {} {} = {};", type_name, c.id.original, c.expr)?;
        Ok(())
    }
}