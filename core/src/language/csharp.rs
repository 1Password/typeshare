use crate::parser::{remove_dash_from_identifier, ParsedData};
use crate::rename::RenameExt;
use crate::rust_types::{RustType, RustTypeFormatError, SpecialRustType};
use crate::{
    language::{Language, SupportedLanguage},
    rust_types::{RustEnum, RustEnumVariant, RustField, RustStruct, RustTypeAlias},
};
use itertools::Itertools;
use joinery::JoinableIterator;
use lazy_format::lazy_format;
use std::io;
use std::{collections::HashMap, io::Write};

/// All information needed to generate C# type-code
#[derive(Default)]
pub struct CSharp {
    /// Mappings from Rust type names to C# type names
    pub type_mappings: HashMap<String, String>,
    /// Whether or not to exclude the version header that normally appears at the top of generated code.
    /// If you aren't generating a snapshot test, this setting can just be left as a default (false)
    pub no_version_header: bool,
    /// Namespace to use in the generated file
    pub namespace: String,
    /// Disable C# property naming convention and follow Serde renaming rules on properties
    pub without_csharp_naming_convention: bool,
}

impl Language for CSharp {
    fn type_map(&mut self) -> &HashMap<String, String> {
        &self.type_mappings
    }

    fn format_type(
        &mut self,
        ty: &RustType,
        generic_types: &[String],
    ) -> Result<String, RustTypeFormatError> {
        match ty {
            RustType::Simple { id } => self.format_simple_type(id, generic_types),
            RustType::Generic { id, parameters } => {
                self.format_generic_type(id, parameters.as_slice(), generic_types)
            }
            RustType::Special(special) => self.format_special_type(special, generic_types),
        }
        .map(|name| with_generic_naming_convention(generic_types, &name))
    }

    fn format_special_type(
        &mut self,
        special_ty: &SpecialRustType,
        generic_types: &[String],
    ) -> Result<String, RustTypeFormatError> {
        match special_ty {
            SpecialRustType::Vec(rtype) => Ok(format!(
                "IEnumerable<{}>",
                self.format_type(rtype, generic_types)?
            )),
            SpecialRustType::Array(rtype, _len) => {
                Ok(format!("{}[]", self.format_type(rtype, generic_types)?))
            }
            SpecialRustType::Slice(rtype) => Ok(format!(
                "IEnumerable<{}>",
                self.format_type(rtype, generic_types)?
            )),
            SpecialRustType::Option(rtype) => self.format_type(rtype, generic_types),
            SpecialRustType::HashMap(rtype1, rtype2) => Ok(format!(
                "IDictionary<{}, {}>",
                match rtype1.as_ref() {
                    RustType::Simple { id } if generic_types.contains(id) => {
                        return Err(RustTypeFormatError::GenericKeyForbiddenInTS(id.clone()));
                    }
                    _ => self.format_type(rtype1, generic_types)?,
                },
                self.format_type(rtype2, generic_types)?
            )),
            SpecialRustType::Unit => Err(RustTypeFormatError::TypeUnitInCS()),
            SpecialRustType::String => Ok("string".into()),
            SpecialRustType::Char => Ok("char".into()),
            SpecialRustType::I8 => Ok("short".into()),
            SpecialRustType::I16 => Ok("short".into()),
            SpecialRustType::U8 => Ok("ushort".into()),
            SpecialRustType::U16 => Ok("ushort".into()),
            SpecialRustType::I32 => Ok("int".into()),
            SpecialRustType::U32 => Ok("uint".into()),
            SpecialRustType::I54 => Ok("long".into()),
            SpecialRustType::I64 => Ok("long".into()),
            SpecialRustType::U53 => Ok("ulong".into()),
            SpecialRustType::U64 => Ok("ulong".into()),
            SpecialRustType::F32 => Ok("float".into()),
            SpecialRustType::F64 => Ok("double".into()),
            SpecialRustType::Bool => Ok("bool".into()),
            SpecialRustType::ISize => Ok("nint".into()),
            SpecialRustType::USize => Ok("nuint".into()),
        }
    }

    fn begin_file(&mut self, w: &mut dyn Write, _parsed_data: &ParsedData) -> io::Result<()> {
        if !self.no_version_header {
            writeln!(w, "/*")?;
            writeln!(w, " Generated by typeshare {}", env!("CARGO_PKG_VERSION"))?;
            writeln!(w, "*/")?;
        }

        writeln!(w, "#nullable enable")?;
        writeln!(w)?;

        writeln!(w, "using System.Reflection;")?;
        writeln!(w, "using JsonSubTypes;")?;
        writeln!(w, "using Newtonsoft.Json;")?;
        writeln!(w, "using System.Runtime.Serialization;")?;
        writeln!(w)?;

        if !self.namespace.is_empty() {
            writeln!(w, "namespace {};", self.namespace)?;
            writeln!(w)?;
        }

        Ok(())
    }

    fn write_type_alias(&mut self, _w: &mut dyn Write, ty: &RustTypeAlias) -> io::Result<()> {
        Err(io::Error::new(
            io::ErrorKind::Unsupported,
            RustTypeFormatError::TypeAliasesForbiddenInCS(format!(
                "C# 11 does not support type aliases. At type alias \"{}\".",
                ty.id.original
            )),
        ))
    }

    fn write_struct(&mut self, w: &mut dyn Write, rs: &RustStruct) -> io::Result<()> {
        self.write_comments(w, 0, &rs.comments)?;
        writeln!(
            w,
            "public class {}{} {{",
            rs.id.renamed,
            (!rs.generic_types.is_empty())
                .then(|| {
                    format!(
                        "<{}>",
                        with_generic_definition_naming_convention(rs.generic_types.as_slice())
                    )
                })
                .unwrap_or_default()
        )?;

        rs.fields
            .iter()
            .try_for_each(|f| self.write_field(w, f, &rs.generic_types.as_slice()))?;

        writeln!(w, "}}\n")
    }

    fn write_enum(&mut self, w: &mut dyn Write, e: &RustEnum) -> io::Result<()> {
        self.write_types_for_anonymous_structs(w, e, &|variant_name| {
            format!("{}{}Inner", &e.shared().id.renamed, variant_name)
        })?;
        self.write_comments(w, 0, &e.shared().comments)?;

        let generic_parameters = (!e.shared().generic_types.is_empty())
            .then(|| {
                format!(
                    "<{}>",
                    with_generic_definition_naming_convention(&e.shared().generic_types)
                )
            })
            .unwrap_or_default();

        match e {
            RustEnum::Unit(shared) => {
                write!(
                    w,
                    "public enum {}{}\n{{",
                    shared.id.renamed, generic_parameters
                )?;

                self.write_enum_variants(w, e)?;

                writeln!(w, "\n}}\n")
            }
            RustEnum::Algebraic { shared, .. } => {
                write_discriminated_union_json_attributes(w, e)?;
                write!(
                    w,
                    "public abstract record {}{} \n{{",
                    shared.id.renamed, generic_parameters
                )?;

                self.write_enum_variants(w, e)?;

                writeln!(w, "\n}}\n")?;
                writeln!(w)
            }
        }
    }

    fn write_imports(
        &mut self,
        _writer: &mut dyn Write,
        _imports: super::ScopedCrateTypes<'_>,
    ) -> std::io::Result<()> {
        todo!()
    }
}

fn write_discriminated_union_json_attributes(w: &mut dyn Write, e: &RustEnum) -> io::Result<()> {
    match e {
        RustEnum::Algebraic {
            tag_key,
            content_key: _content_key,
            shared,
        } => {
            writeln!(w, "[JsonConverter(typeof(JsonSubtypes), \"{}\")]", tag_key)?;
            let case_attributes = shared.variants.iter().map(|v| {
                let case_name = match v {
                    RustEnumVariant::AnonymousStruct { shared, .. } => &shared.id.original,
                    RustEnumVariant::Unit(shared) => &shared.id.original,
                    RustEnumVariant::Tuple { shared, .. } => &shared.id.original,
                };
                format!(
                    "[JsonSubtypes.KnownSubType(typeof({0}), \"{0}\")]",
                    case_name,
                )
            });

            writeln!(w, "{}", case_attributes.join_with("\n"))
        }
        _ => Ok(()),
    }
}

impl CSharp {
    fn write_enum_variants(&mut self, w: &mut dyn Write, e: &RustEnum) -> io::Result<()> {
        match e {
            // Write all the unit variants out (there can only be unit variants in
            // this case)
            RustEnum::Unit(shared) => shared.variants.iter().try_for_each(|v| match v {
                RustEnumVariant::Unit(shared) => {
                    writeln!(w)?;
                    self.write_comments(w, 1, &shared.comments)?;
                    if shared.id.renamed != shared.id.original {
                        writeln!(w, "\t[EnumMember(Value = {:?})]", &shared.id.renamed)?;
                    }
                    writeln!(w, "\t{},", shared.id.original)
                }
                _ => unreachable!(),
            }),

            // Write all the algebraic variants out (all three variant types are possible
            // here)
            RustEnum::Algebraic {
                tag_key: _tag_key,
                content_key,
                shared,
            } => shared.variants.iter().try_for_each(|v| {
                writeln!(w)?;
                self.write_comments(w, 1, &v.shared().comments)?;
                let generic_types = &e.shared().generic_types;
                let base_type = &e.shared().id.original;
                let base_generics_names = generic_types
                    .iter()
                    .map(|name| with_generic_naming_convention(generic_types, &name))
                    .collect_vec();

                let base_generic_types = match base_generics_names.as_slice() {
                    [] => String::new(),
                    values => format!("<{}>", values.iter().join_with(", ")),
                };

                match v {
                    RustEnumVariant::Unit(shared) => write!(
                        w,
                        "\tpublic record {}(): {}{}();",
                        shared.id.original, base_type, base_generic_types,
                    ),
                    RustEnumVariant::Tuple { ty, shared } => {
                        let r#type = self
                            .format_type(&ty, e.shared().generic_types.as_slice())
                            .map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;
                        write!(
                            w,
                            "\tpublic record {}({}{} {}) : {}{}();",
                            shared.id.original,
                            r#type,
                            ty.is_optional().then(|| "?").unwrap_or_default(),
                            content_key.to_pascal_case(),
                            base_type,
                            base_generic_types,
                        )
                    }
                    RustEnumVariant::AnonymousStruct { fields, shared } => {
                        let generics = fields
                            .iter()
                            .flat_map(|field| {
                                generic_types
                                    .iter()
                                    .filter(|g| field.ty.contains_type(g))
                                    .map(|name| {
                                        with_generic_naming_convention(generic_types, &name)
                                    })
                            })
                            .unique()
                            .collect_vec();

                        let generics = lazy_format!(match (generics.is_empty()) {
                            false => ("<{}>", generics.iter().join_with(", ")),
                            true => (""),
                        });

                        write!(
                            w,
                            "\tpublic record {}({}{}Inner{} {}): {}{}();",
                            shared.id.renamed,
                            e.shared().id.original,
                            shared.id.original,
                            generics,
                            content_key.to_pascal_case(),
                            base_type,
                            base_generic_types,
                        )
                    }
                }
            }),
        }
    }

    fn write_field(
        &mut self,
        w: &mut dyn Write,
        field: &RustField,
        generic_types: &[String],
    ) -> io::Result<()> {
        self.write_comments(w, 1, &field.comments)?;
        let cs_ty: String = match field.type_override(SupportedLanguage::CSharp) {
            Some(type_override) => type_override.to_owned(),
            None => self
                .format_type(&field.ty, generic_types)
                .map_err(|e| io::Error::new(io::ErrorKind::Other, e))?,
        };

        let optional = field.ty.is_optional() || field.has_default;
        let is_readonly = field
            .decorators
            .get(&SupportedLanguage::CSharp)
            .filter(|v| v.iter().any(|dec| dec.name() == "readonly"))
            .is_some();

        let property_name = if self.without_csharp_naming_convention {
            field.id.renamed.clone()
        } else {
            csharp_property_aware_rename(&field.id.renamed)
        };

        writeln!(
            w,
            "{}\tpublic {}{} {} {{ get;{} }}",
            if !optional {
                "\t[JsonProperty(Required = Required.Always)]\n"
            } else {
                ""
            },
            cs_ty,
            optional.then(|| "?").unwrap_or_default(),
            property_name,
            if !is_readonly { " set;" } else { "" },
        )?;

        Ok(())
    }

    fn write_comments(
        &mut self,
        w: &mut dyn Write,
        indent: usize,
        comments: &[String],
    ) -> io::Result<()> {
        // Only attempt to write a comment if there are some, otherwise we're Ok()
        if !comments.is_empty() {
            let comment: String = {
                let tab_indent = "\t".repeat(indent);
                // If there's only one comment then keep it on the same line, otherwise we'll make a nice multi-line comment
                if comments.len() == 1 {
                    format!("{}/** {} */", tab_indent, comments.first().unwrap())
                } else {
                    let joined_comments = comments.join(&format!("\n{} * ", tab_indent));
                    format!(
                        "{tab}/**
{tab} * {comment}
{tab} */",
                        tab = tab_indent,
                        comment = joined_comments
                    )
                }
            };
            writeln!(w, "{}", comment)?;
        }
        Ok(())
    }
}

fn with_generic_definition_naming_convention(generic_types: &[String]) -> String {
    generic_types
        .into_iter()
        .map(|name| {
            if name == "T" {
                return name.clone();
            } else {
                format!("T{}", name.to_string())
            }
        })
        .collect::<Vec<String>>()
        .join(", ")
}

fn with_generic_naming_convention<'a, 'b>(generic_types: &'a [String], name: &'b String) -> String {
    if generic_types
        .into_iter()
        .any(|generic_name| generic_name == name && generic_name != "T")
    {
        format!("T{}", name.to_string())
    } else {
        name.clone()
    }
}

fn csharp_property_aware_rename(name: &str) -> String {
    remove_dash_from_identifier(name)
        .to_pascal_case()
        .to_string()
}

#[cfg(test)]
mod tests {
    #[test]
    fn rename_property() {
        let input = "open_links";
        let expected = "OpenLinks";
        let actual = super::csharp_property_aware_rename(input);

        assert_eq!(actual, expected)
    }
}
