use std::{
    borrow::Cow,
    collections::HashMap,
    io::{self, Write},
};

use anyhow::Context;
use itertools::Itertools;
use joinery::JoinableIterator;
use serde::{Deserialize, Serialize};
use thiserror::Error;
use typeshare_model::{decorator::Value, prelude::*};

#[derive(Serialize, Deserialize)]
#[serde(rename_all = "kebab-case")]
pub struct Config {
    /// Mappings from Rust type names to Typescript type names
    #[serde(default, alias = "type_mappings")]
    type_mappings: HashMap<String, String>,

    /// Whether or not to exclude the version header that normally appears at the top of generated code.
    /// If you aren't generating a snapshot test, this setting can just be left as a default (false)
    #[serde(default)]
    no_version_header: bool,
}

/// All information needed to generate Typescript type-code
#[derive(Default, Debug)]
pub struct TypeScript {
    pub type_mappings: HashMap<TypeName, TypeName>,
    pub no_version_header: bool,
}

#[derive(Debug, Clone, Error)]
pub enum FormatTypeError {
    #[error("Can't have 64-bit or larger integers in typescript")]
    LargeInteger,

    #[error("Can't have generic types as map keys in typescript")]
    GenericMapKey,
}

impl Language<'_> for TypeScript {
    type Config = Config;

    const NAME: &'static str = "typescript";

    fn new_from_config(config: Self::Config) -> anyhow::Result<Self> {
        Ok(Self {
            no_version_header: config.no_version_header,
            type_mappings: config
                .type_mappings
                .into_iter()
                .map(|(key, value)| (TypeName::new_string(key), TypeName::new_string(value)))
                .collect(),
        })
    }

    fn mapped_type(&self, type_name: &TypeName) -> Option<Cow<'_, str>> {
        self.type_mappings
            .get(type_name)
            .map(|name| name.as_str())
            .map(Cow::Borrowed)
    }

    fn output_filename_for_crate(&self, crate_name: &CrateName) -> String {
        format!("typeshare_{crate_name}.ts")
    }

    fn format_special_type(
        &self,
        special_ty: &SpecialRustType,
        generic_context: &[TypeName],
    ) -> anyhow::Result<String> {
        match special_ty {
            SpecialRustType::Vec(rtype) | SpecialRustType::Slice(rtype) => {
                Ok(format!("{}[]", self.format_type(rtype, generic_context)?))
            }
            SpecialRustType::Array(rtype, len) => {
                let formatted_type = self.format_type(rtype, generic_context)?;
                Ok(format!(
                    "[{}]",
                    std::iter::repeat(&formatted_type)
                        .take(*len)
                        .join_with(", ")
                ))
            }
            // We add optionality above the type formatting level
            SpecialRustType::Option(rtype) => self.format_type(rtype, generic_context),
            SpecialRustType::HashMap(key, value) => Ok(format!(
                "Record<{}, {}>",
                match key.as_ref() {
                    RustType::Simple { id } if generic_context.contains(id) => {
                        anyhow::bail!("can't use a generic type as a record key")
                    }
                    _ => self.format_type(key, generic_context)?,
                },
                self.format_type(value, generic_context)?
            )),
            SpecialRustType::Unit => Ok("undefined".into()),
            SpecialRustType::String => Ok("string".into()),
            SpecialRustType::Char => Ok("string".into()),
            SpecialRustType::I8
            | SpecialRustType::U8
            | SpecialRustType::I16
            | SpecialRustType::U16
            | SpecialRustType::I32
            | SpecialRustType::U32
            | SpecialRustType::I54
            | SpecialRustType::U53
            | SpecialRustType::F32
            | SpecialRustType::F64 => Ok("number".into()),
            SpecialRustType::Bool => Ok("boolean".into()),
            SpecialRustType::U64
            | SpecialRustType::I64
            | SpecialRustType::ISize
            | SpecialRustType::USize => anyhow::bail!("can't use 64+ bit integers in typescript"),
            ty => anyhow::bail!("unsupported type {ty:?}"),
        }
    }

    fn begin_file(&self, w: &mut impl Write, _mode: FilesMode<&CrateName>) -> anyhow::Result<()> {
        if !self.no_version_header {
            writeln!(
                w,
                "/*\n\
                  Generated by typeshare {}\n\
                 */",
                env!("CARGO_PKG_VERSION")
            )?;
        }
        Ok(())
    }

    fn write_imports<'a, Crates, Types>(
        &self,
        writer: &mut impl Write,
        _crate_name: &CrateName,
        imports: Crates,
    ) -> anyhow::Result<()>
    where
        Crates: IntoIterator<Item = (&'a CrateName, Types)>,
        Types: IntoIterator<Item = &'a TypeName>,
    {
        for (crate_name, types) in imports {
            write!(writer, "import {{ ")?;
            let ty_list = types.into_iter().join(", ");
            write!(writer, "{ty_list}")?;
            writeln!(writer, " }} from \"./{crate_name}\";")?;
        }
        writeln!(writer)?;

        Ok(())
    }

    fn write_type_alias(&self, w: &mut impl Write, ty: &RustTypeAlias) -> anyhow::Result<()> {
        self.write_comments(w, 0, &ty.comments)?;

        let r#type = self
            .format_type(&ty.ty, ty.generic_types.as_slice())
            .map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;

        writeln!(
            w,
            "export type {}{} = {}{};\n",
            ty.id.original,
            (!ty.generic_types.is_empty())
                .then(|| format!("<{}>", ty.generic_types.iter().join_with(", ")))
                .unwrap_or_default(),
            r#type,
            ty.ty
                .is_optional()
                .then_some(" | undefined")
                .unwrap_or_default(),
        )?;

        Ok(())
    }

    fn write_struct(&self, w: &mut impl Write, rs: &RustStruct) -> anyhow::Result<()> {
        self.write_comments(w, 0, &rs.comments)?;
        writeln!(
            w,
            "export interface {}{} {{",
            rs.id.original,
            (!rs.generic_types.is_empty())
                .then(|| format!("<{}>", rs.generic_types.iter().join_with(", ")))
                .unwrap_or_default()
        )?;

        rs.fields
            .iter()
            .try_for_each(|f| self.write_field(w, f, &rs.generic_types))?;

        writeln!(w, "}}\n")?;

        Ok(())
    }

    fn write_enum(&self, w: &mut impl Write, e: &RustEnum) -> anyhow::Result<()> {
        self.write_comments(w, 0, &e.shared().comments)?;

        let generic_parameters = (!e.shared().generic_types.is_empty())
            .then(|| format!("<{}>", e.shared().generic_types.iter().join_with(", ")))
            .unwrap_or_default();

        match e {
            RustEnum::Unit { shared, .. } => {
                write!(
                    w,
                    "export enum {}{} {{",
                    shared.id.original, generic_parameters
                )?;

                self.write_enum_variants(w, e)?;

                writeln!(w, "\n}}\n")?;
            }
            RustEnum::Algebraic { shared, .. } => {
                write!(
                    w,
                    "export type {}{} = ",
                    shared.id.original, generic_parameters
                )?;

                self.write_enum_variants(w, e)?;

                write!(w, ";\n\n")?;
            }
        }

        Ok(())
    }

    fn write_const(&self, w: &mut impl Write, c: &RustConst) -> anyhow::Result<()> {
        let expr = match c.expr {
            RustConstExpr::Int(int) => int,
            ref expr => anyhow::bail!("unsupported const value '{expr:?}'"),
        };

        let const_type = self
            .format_type(&c.ty, &[])
            .map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;

        writeln!(
            w,
            "export const {ident}: {const_type} = {expr};",
            ident = c.id.original.as_str().to_uppercase(),
        )?;

        Ok(())
    }

    fn exclude_from_import_analysis(&self, name: &TypeName) -> bool {
        self.type_mappings.contains_key(name)
    }
}

impl TypeScript {
    fn write_enum_variants(&self, w: &mut dyn Write, e: &RustEnum) -> anyhow::Result<()> {
        match e {
            // Write all the unit variants out (there can only be unit variants in
            // this case)
            RustEnum::Unit { unit_variants, .. } => unit_variants.iter().try_for_each(|variant| {
                writeln!(w)?;
                self.write_comments(w, 1, &variant.comments)?;
                write!(
                    w,
                    "\t{} = {:?},",
                    variant.id.original,
                    &variant.id.renamed.as_str()
                )?;
                Ok(())
            }),

            // Write all the algebraic variants out (all three variant types are possible
            // here)
            RustEnum::Algebraic {
                tag_key,
                content_key,
                variants,
                ..
            } => variants.iter().try_for_each(|v| {
                writeln!(w)?;
                self.write_comments(w, 1, &v.shared().comments)?;
                match v {
                    RustEnumVariant::Unit(shared) => write!(
                        w,
                        "\t| {{ {}: {:?}, {}?: undefined }}",
                        tag_key,
                        shared.id.renamed.as_str(),
                        content_key
                    )
                    .with_context(|| format!("error writing unit variant {}", shared.id.original)),
                    RustEnumVariant::Tuple { ty, shared } => {
                        let r#type = self
                            .format_type(ty, e.shared().generic_types.as_slice())
                            .with_context(|| {
                                format!("error formatting type for variant {}", shared.id.original)
                            })?;

                        write!(
                            w,
                            "\t| {{ {}: {:?}, {}{}: {} }}",
                            tag_key,
                            shared.id.renamed.as_str(),
                            content_key,
                            ty.is_optional().then_some("?").unwrap_or_default(),
                            r#type
                        )
                        .with_context(|| {
                            format!("error writing newtype variant {}", shared.id.original)
                        })
                    }
                    RustEnumVariant::AnonymousStruct { fields, shared } => {
                        writeln!(
                            w,
                            "\t| {{ {}: {:?}, {}: {{",
                            tag_key,
                            shared.id.renamed.as_str(),
                            content_key
                        )?;

                        fields
                            .iter()
                            .try_for_each(|f| {
                                self.write_field(w, f, e.shared().generic_types.as_slice())
                                    .with_context(|| {
                                        format!("error writing field {}", f.id.original)
                                    })
                            })
                            .with_context(|| {
                                format!("error writing variant {}", shared.id.original)
                            })?;

                        write!(w, "}}")?;
                        write!(w, "}}")?;

                        Ok(())
                    }
                    kind => anyhow::bail!("unsupported enum shape {kind:?}"),
                }
            }),
        }
    }

    fn write_field(
        &self,
        w: &mut dyn Write,
        field: &RustField,
        generic_types: &[TypeName],
    ) -> anyhow::Result<()> {
        self.write_comments(w, 1, &field.comments)?;

        let ty = match field.decorators.type_override_for_lang("typescript") {
            Some(ty) => ty.to_owned(),
            None => self
                .format_type(&field.ty, generic_types)
                .context("failed for format type")?,
        };

        let optional = field.ty.is_optional() || field.has_default;
        let double_optional = field.ty.is_double_optional();

        let readonly = match field
            .decorators
            .get_all("typescript")
            .iter()
            .filter_map(|dec| match dec {
                Value::Nested(nested) => Some(nested),
                _ => None,
            })
            .any(|dec| dec.any("readonly", |value| matches!(value, Value::None)))
        {
            true => "readonly ",
            false => "",
        };

        writeln!(
            w,
            "\t{readonly}{name}{opt}: {ty}{double_opt};",
            name = typescript_property_aware_rename(field.id.renamed.as_str()),
            opt = if optional { "?" } else { "" },
            double_opt = if double_optional { " | null" } else { "" },
        )?;

        Ok(())
    }

    fn write_comments(
        &self,
        w: &mut dyn Write,
        indent: usize,
        comments: &[String],
    ) -> anyhow::Result<()> {
        // Only attempt to write a comment if there are some, otherwise we're Ok()
        if !comments.is_empty() {
            let comment: String = {
                let tab_indent = "\t".repeat(indent);
                // If there's only one comment then keep it on the same line, otherwise we'll make a nice multi-line comment
                if comments.len() == 1 {
                    format!("{}/** {} */", tab_indent, comments.first().unwrap())
                } else {
                    let joined_comments = comments.join(&format!("\n{} * ", tab_indent));
                    format!(
                        "{tab}/**
{tab} * {comment}
{tab} */",
                        tab = tab_indent,
                        comment = joined_comments
                    )
                }
            };
            writeln!(w, "{}", comment)?;
        }
        Ok(())
    }
}

fn typescript_property_aware_rename(name: &str) -> String {
    if name.chars().any(|c| c == '-') {
        return format!("{:?}", name);
    }
    name.to_string()
}
